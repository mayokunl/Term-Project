# -*- coding: utf-8 -*-
"""Termproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-R92xvvxY_P_A7oXn8ddvu-_2KMju07Y
"""

import random
def buildTable(X, Y, match=1, mismatch=-1, gap=-1):
    print("Sequence 1:", X)
    print("Sequence 2:", Y)

    M = len(X)
    N = len(Y)

    # Initialize the alignment table with zeros
    opt = [[0] * (N + 1) for _ in range(M + 1)]

    # Initialize the first row and first column with gap penalties
    for i in range(1, M + 1):
        opt[i][0] = opt[i - 1][0] + gap
    for j in range(1, N + 1):
        opt[0][j] = opt[0][j - 1] + gap

    # Calculate the optimal score in each cell
    for i in range(1, M + 1):
        for j in range(1, N + 1):
            match_mismatch_score = match if X[i - 1] == Y[j - 1] else mismatch
            diagonal_score = opt[i - 1][j - 1] + match_mismatch_score
            left_score = opt[i][j - 1] + gap
            top_score = opt[i - 1][j] + gap
            opt[i][j] = max(diagonal_score, left_score, top_score)

    # Print the final alignment table
    for row in opt:
        print(row)

    # Return the alignment table
    return opt

def myLCS_DP(X, Y, table, match=1, mismatch=-1, gap=-1):
    i = len(X)
    j = len(Y)
    first = ''  # alignment for X
    second = ''  # alignment for Y
    length_of_lcs = 0  # initialize the length of the longest common subsequence

    while i > 0 or j > 0:
        current_score = table[i][j]
        left_cell = table[i][j - 1]
        top_cell = table[i - 1][j]
        diagonal_cell = table[i - 1][j - 1]

        if i > 0 and j > 0 and current_score == diagonal_cell + (match if X[i - 1] == Y[j - 1] else mismatch):
            first = X[i - 1] + first
            second = Y[j - 1] + second
            i -= 1
            j -= 1
            length_of_lcs += 1
        elif j > 0 and current_score == left_cell + gap:
            first = '-' + first
            second = Y[j - 1] + second
            j -= 1
        else:
            first = X[i - 1] + first
            second = '-' + second
            i -= 1

    # Print the optimal alignment
    print("Optimal Alignment:")
    print(first)
    print(second)

    # Print the length of the longest common subsequence
    print("LCS has length of:", length_of_lcs)

# Function to generate a random DNA sequence of a given length
def generate_random_sequence(length):
    return ''.join(random.choice('ACGT') for _ in range(length))



n = 15
random_sequence3 = generate_random_sequence(n)
random_sequence4 = generate_random_sequence(n)

# Build the alignment table
alignment_table_custom_length = buildTable(random_sequence3, random_sequence4)

# Call TraceBack with the alignment table
myLCS_DP(random_sequence3, random_sequence4, alignment_table_custom_length)

def myLCS_Recursive(X, Y, match=1, mismatch=-1, gap=-1):
    def lcs_recursive(i, j):
        if i == 0 or j == 0:
            return 0, ''

        match_mismatch_score = match if X[i - 1] == Y[j - 1] else mismatch

        diagonal_score, diagonal_alignment = lcs_recursive(i - 1, j - 1)
        left_score, left_alignment = lcs_recursive(i, j - 1)
        top_score, top_alignment = lcs_recursive(i - 1, j)

        if match_mismatch_score + diagonal_score >= max(left_score, top_score):
            return match_mismatch_score + diagonal_score, diagonal_alignment + X[i - 1]
        elif left_score >= top_score:
            return left_score, left_alignment
        else:
            return top_score, top_alignment

    length_of_lcs, lcs_alignment = lcs_recursive(len(X), len(Y))

    # Reverse the alignment since we built it from the end
    lcs_alignment = lcs_alignment[::-1]

    # Print the optimal alignment
    print("Optimal Alignment:")
    print(X)
    print(lcs_alignment)

    # Print the length of the longest common subsequence
    print("LCS:", length_of_lcs)

# Function to generate a random DNA sequence of a given length
def generate_random_sequence(length):
    return ''.join(random.choice('ACGT') for _ in range(length))

n = 15
random_sequence3 = generate_random_sequence(n)
random_sequence4 = generate_random_sequence(n)

# Call LCS using recursive programming
myLCS_Recursive(random_sequence3, random_sequence4)

